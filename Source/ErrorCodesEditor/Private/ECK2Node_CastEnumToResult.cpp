// Copyright 2022 Miraganic Studios. All rights reserved.


#include "ECK2Node_CastEnumToResult.h"

#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintFieldNodeSpawner.h"
#include "ECErrorCategory.h"
#include "ECErrorFunctionLibrary.h"
#include "ECResult.h"
#include "EdGraphUtilities.h"
#include "EditorCategoryUtils.h"
#include "K2Node_CallFunction.h"
#include "KismetCompiler.h"
#include "Kismet/KismetNodeHelperLibrary.h"
#include "Kismet2/CompilerResultsLog.h"

#define LOCTEXT_NAMESPACE "ErrorCodesEditor_K2NodeCastEnumToResult"

UECK2Node_CastEnumToResult::UECK2Node_CastEnumToResult(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	Enum = nullptr;
}

void UECK2Node_CastEnumToResult::AllocateDefaultPins()
{
	UEdGraphPin* InputPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Byte, Enum, GetEnumInputPinName());
	GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(InputPin);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Struct, FECResult::StaticStruct(), UEdGraphSchema_K2::PN_ReturnValue);
	Super::AllocateDefaultPins();
}

FText UECK2Node_CastEnumToResult::GetTooltipText() const
{
	if (!IsValid(Enum))
	{
		return LOCTEXT("Tooltip_Invalid", "Enum to Result (Invalid Enum)");
	}
	else if (CachedTooltip.IsOutOfDate(this))
	{
		CachedTooltip.SetCachedText(FText::Format(LOCTEXT("Tooltip_Valid", "Enum to Result ({0})"),
			Enum->GetDisplayNameText()), this);
	}

	return CachedTooltip;
}

FText UECK2Node_CastEnumToResult::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return GetTooltipText();
}

FSlateIcon UECK2Node_CastEnumToResult::GetIconAndTint(FLinearColor& OutColor) const
{
	static FSlateIcon Icon("EditorStyle", "GraphEditor.Enum_16x");
	return Icon;
}

void UECK2Node_CastEnumToResult::ValidateNodeDuringCompilation(FCompilerResultsLog& MessageLog) const
{
	Super::ValidateNodeDuringCompilation(MessageLog);
	if (!Enum)
	{
		MessageLog.Error(*LOCTEXT("CastFromNullEnumError", "Undefined Enum in @@").ToString(), this);
	}
}

FText UECK2Node_CastEnumToResult::GetCompactNodeTitle() const
{
	return LOCTEXT("CastSymbol", "\x2022");
}

void UECK2Node_CastEnumToResult::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	if (!Enum)
	{
		return;
	}

	const UEdGraphSchema_K2* Schema = CompilerContext.GetSchema();

	// FUNCTION NODE
	const FName FunctionName = GetFunctionName();
	const UFunction* Function = UECErrorFunctionLibrary::StaticClass()->FindFunctionByName(FunctionName);
	check(IsValid(Function));
	UK2Node_CallFunction* FunctionCall = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph); 
	FunctionCall->SetFromFunction(Function);
	FunctionCall->AllocateDefaultPins();
	check(FunctionCall->IsNodePure());

	// Enum pin
	UEdGraphPin* FunctionEnumPin = FunctionCall->FindPinChecked(TEXT("Enum"));
	Schema->TrySetDefaultObject(*FunctionEnumPin, Enum);
	check(FunctionEnumPin->DefaultObject == Enum);

	// Enum value pin
	UEdGraphPin* OrgInputPin = FindPinChecked(GetEnumInputPinName());
	UEdGraphPin* FunctionIndexPin = FunctionCall->FindPinChecked(TEXT("EnumValue"));
	
	int32 Index = Enum->GetIndexByName(*OrgInputPin->DefaultValue);
	if (Index != INDEX_NONE)
	{
		FunctionIndexPin->DefaultValue = FString::FromInt(Enum->GetValueByIndex(Index));
	}
	
	// Output pin
	UEdGraphPin* FunctionReturnPin = FunctionCall->FindPinChecked(UEdGraphSchema_K2::PN_ReturnValue);
	UEdGraphPin* OrgReturnPin = FindPinChecked(UEdGraphSchema_K2::PN_ReturnValue);
	CompilerContext.MovePinLinksToIntermediate(*OrgReturnPin, *FunctionReturnPin);
}

bool UECK2Node_CastEnumToResult::IsConnectionDisallowed(const UEdGraphPin* MyPin,
	const UEdGraphPin* OtherPin,
	FString& OutReason
	) const
{
	// Note that for the output pin the cast will fail.
	const UEnum* SubCategoryObject = Cast<UEnum>(MyPin->PinType.PinSubCategoryObject.Get());
	if (SubCategoryObject && SubCategoryObject != Enum)
	{
		return true;
	}

	return false;
}

void UECK2Node_CastEnumToResult::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);

	ActionRegistrar.RegisterEnumActions(FBlueprintActionDatabaseRegistrar::FMakeEnumSpawnerDelegate::CreateLambda(
		[](const UEnum* InEnum) -> UBlueprintNodeSpawner*
		{
			UBlueprintFieldNodeSpawner* NodeSpawner = UBlueprintFieldNodeSpawner::Create(StaticClass(), InEnum);
			check(IsValid(NodeSpawner));
			TWeakObjectPtr<UEnum> NonConstEnumPtr = const_cast<UEnum*>(InEnum);
			if (!InEnum->HasMetaData(TEXT("ErrorCategory")) && !InEnum->IsA<UECErrorCategory>())
			{
				return nullptr;
			}
			NodeSpawner->SetNodeFieldDelegate = UBlueprintFieldNodeSpawner::FSetNodeFieldDelegate::CreateLambda(
			[](UEdGraphNode* NewNode, FFieldVariant EnumField, TWeakObjectPtr<UEnum> EnumPtr)
				{
					UECK2Node_CastEnumToResult* EnumNode = CastChecked<UECK2Node_CastEnumToResult>(NewNode);
					EnumNode->Enum = EnumPtr.Get();
				}, NonConstEnumPtr);

			return NodeSpawner;
		}));
}

FText UECK2Node_CastEnumToResult::GetMenuCategory() const
{
	return FEditorCategoryUtils::GetCommonCategory(FCommonEditorCategory::Enum);
}

void UECK2Node_CastEnumToResult::ReloadEnum(UEnum* InEnum)
{
	Enum = InEnum;
	CachedTooltip.MarkDirty();
}

FName UECK2Node_CastEnumToResult::GetFunctionName() const
{
	return GET_FUNCTION_NAME_CHECKED(UECErrorFunctionLibrary, EnumToResult);
}

FName UECK2Node_CastEnumToResult::GetEnumInputPinName()
{
	return TEXT("InputEnum");
}

#undef LOCTEXT_NAMESPACE
